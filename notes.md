` python3 -m unittest --verbose `

```
latest run

Ran 73 tests in 2.718s

FAILED (failures=37, errors=9)

```

```
True and False are singletons.
```

```
you can use the module paradigm to implement a singleton.
```

```
[3] pdes - the primary designation of the NEO. This is a unique identifier in the database, and its "name" to computer systems.
[4] name - the International Astronomical Union (IAU) name of the NEO. This is its "name" to humans.
[6] neo - near earth object
[7] pha - whether NASA has marked the NEO as a "Potentially Hazardous Asteroid," roughly meaning that it's large and can come quite close to Earth.
[15] diameter - the NEO's diameter (from an equivalent sphere) in kilometers.
```

```
des - primary designation of object
cd - time of close approach
dist - nominal approach distance (au)
v_rel - velocity relative to earth
```

The inspect subcommand inspects a single NEO, printing its details in a human-readable format. The NEO is specified with exactly one of the --pdes option (the primary designation) and the --name option (the IAU name). The --verbose flag additionally prints out, in a human-readable form, all known close approaches to Earth made by this NEO. Each of these options has an abbreviated version.

For an NEO to be found with the inspect subcommand, the given primary designation or IAU name must match the data exactly, so if an NEO is mysteriously missing, double-check the spelling and capitalization.

The query subcommand is more significantly more advanced - a query generates a collection of close approaches that match a set of specified filters, and either displays a limited set of those results to standard output or writes the structured results to a file.



    main.py: The main Python script that wraps the command-line tool, orchestrates the data pipeline by invoking the functions and classes that you'll write. You will not need to modify this file.
    models.py: In this file, you'll define Python objects to represent a NearEarthObject and a CloseApproach. These objects will have a few attributes, a human-readable string representation, and perhaps a property or a method here or there.
    extract.py: In this file, you'll write functions to read information from data files, creating NearEarthObjects and CloseApproaches from the data.
    database.py: In this file, you'll define a NEODatabase class to encapsulate the entire data set (connecting NEOs and close approaches) and write methods to get NEOs by primary designation and by name, as well as to query the dataset with a collection of user-specified filters to generate an iterable stream of matching results.
    filters.py: In this file, you'll create a plethora of filters to be used in conjunction with the NEODatabase to query for a stream of matching close approaches. You'll also write a utility function to limit the number of results produced from a stream.
    write.py: Finally, in this file, you'll implement functions to write a stream of results (the CloseApproach objects generated by the NEODatabase) to a file either in JSON format or in CSV format.
    helpers.py: A simple module that provides a few helpful utility functions to convert to and from DateTime objects.





    Task 0: Inspect the data. (data/neos.csv and data/cad.json). You already did this!
    Task 1: Build models to represent the data. (models.py)
    Task 2: Extract the data into a custom database (extract.py and database.py)
    Task 3: Create filters to query the database to generate a stream of matching CloseApproach objects, and limit the result size. (filters.py and database.py)
    Task 4: Save the data to a file. (write.py)
